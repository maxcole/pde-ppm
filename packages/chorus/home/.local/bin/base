#!/usr/bin/env ruby
# frozen_string_literal: true

require "thor"
require "pathname"
require "fileutils"
require "json"

class BaseCLI < Thor
  SHARE_DIR = Pathname.new(Dir.home).join(".local/share/chorus/base")
  VAULT_TEMPLATE = SHARE_DIR.join("vault")
  IGNORE_FILE = Pathname.new(Dir.home).join(".config/chorus/base/ignore")

  def self.exit_on_failure? = true

  desc "new DIR", "Create a new base directory and initialize it"
  def new(dir)
    target = Pathname.pwd.join(dir)

    if target.exist?
      warn "Error: Directory '#{dir}' already exists"
      exit 1
    end

    target.mkpath
    puts "Created #{target}"

    Dir.chdir(target) { init }
  end

  desc "init", "Initialize current directory with base template"
  def init
    target = Pathname.pwd

    unless VAULT_TEMPLATE.exist?
      warn "Error: Vault template not found at #{VAULT_TEMPLATE}"
      exit 1
    end

    copy_template(VAULT_TEMPLATE, target)
    puts "Initialized base at #{target}"
  end

  desc "add PRODUCT", "Add a new product to the vault"
  def add(product)
    root = validate_vault!
    product_dir = root.join("products", product)

    if product_dir.exist?
      warn "Error: Product '#{product}' already exists"
      exit 1
    end

    config = JSON.parse(root.join("_config/base.json").read)

    product_dir.mkpath
    product_dir.join("inbox").mkpath
    %w[epics features stories].each do |dir|
      product_dir.join("backlog", dir).mkpath
    end
    product_dir.join("backlog/tasks").mkpath if config["tasks"] == "file"

    puts "Created product '#{product}' at #{product_dir}"
  end

  desc "update", "Sync paths based on ~/.config/chorus/base/ignore (destructive)"
  option :force, aliases: "-f", type: :boolean, desc: "Required flag to confirm destructive operation"
  option :master, aliases: "-m", type: :boolean, desc: "Sync from current directory back to master template"
  option :dry_run, aliases: "-d", type: :boolean, desc: "Show what would be synced without making changes"
  def update
    dry_run = options[:dry_run]

    unless dry_run || options[:force]
      warn "Error: This is a destructive operation. Use --force or -f to confirm, or --dry-run to preview."
      exit 1
    end

    target = Pathname.pwd

    unless target.join("_config").exist?
      warn "Error: Not a vault root (no _config directory found)"
      exit 1
    end

    unless VAULT_TEMPLATE.exist?
      warn "Error: Vault template not found at #{VAULT_TEMPLATE}"
      exit 1
    end

    unless IGNORE_FILE.exist?
      warn "Error: Ignore file not found at #{IGNORE_FILE}"
      exit 1
    end

    rules = parse_ignore_file(IGNORE_FILE)

    if options[:master]
      sync_files(source: target, dest: VAULT_TEMPLATE, rules:, dry_run:)
    else
      sync_files(source: VAULT_TEMPLATE, dest: target, rules:, dry_run:)
    end
  end

  private

  def validate_vault!
    root = Pathname.pwd

    unless root.join("_config/base.json").exist?
      warn "Error: Not a vault root (no _config/base.json found)"
      exit 1
    end

    unless root.join("products").exist?
      warn "Error: Not a vault root (no products directory found)"
      exit 1
    end

    root
  end

  def parse_ignore_file(path)
    path.readlines.map(&:chomp).reject { |line| line.empty? || line.start_with?("#") }
  end

  def ignored?(path, rules)
    ignored = false

    rules.each do |rule|
      negated = rule.start_with?("!")
      pattern = negated ? rule[1..] : rule

      # Remove trailing slash for matching purposes
      pattern = pattern.chomp("/")

      if match?(path, pattern)
        ignored = !negated
      end
    end

    ignored
  end

  def match?(path, pattern)
    # Handle ** for recursive matching
    if pattern.include?("**")
      regex_pattern = pattern.gsub("**", ".*").gsub("*", "[^/]*").gsub("?", ".")
      return path.match?(/\A#{regex_pattern}\z/)
    end

    # Handle patterns with path separators
    if pattern.include?("/")
      File.fnmatch?(pattern, path, File::FNM_PATHNAME | File::FNM_DOTMATCH)
    else
      # Match against any path component or the full path
      File.fnmatch?(pattern, path, File::FNM_PATHNAME | File::FNM_DOTMATCH) ||
        File.fnmatch?(pattern, File.basename(path), File::FNM_DOTMATCH) ||
        path.split("/").any? { |component| File.fnmatch?(pattern, component, File::FNM_DOTMATCH) }
    end
  end

  def sync_files(source:, dest:, rules:, dry_run:)
    files_to_sync = collect_files(source, rules)

    if dry_run
      puts "Would sync"
      puts "  from: \e[32m#{source}\e[0m"
      puts "  to:   \e[31m#{dest}\e[0m\n\n"
      files_to_sync.each { |f| puts "  #{f}" }
    else
      # Remove existing files/dirs that will be synced
      files_to_sync.map { |f| f.split("/").first }.uniq.each do |top_level|
        dest_path = dest.join(top_level)
        FileUtils.rm_rf(dest_path) if dest_path.exist?
      end

      files_to_sync.each do |relative_path|
        src_file = source.join(relative_path)
        dest_file = dest.join(relative_path)
        dest_file.dirname.mkpath
        FileUtils.cp(src_file, dest_file)
      end

      puts "Updated #{files_to_sync.size} file(s) at #{dest}"
    end
  end

  def collect_files(source, rules)
    files = []

    source.glob("**/*", File::FNM_DOTMATCH).each do |src_file|
      next if src_file.directory?
      next if src_file.basename.to_s == "." || src_file.basename.to_s == ".."

      relative = src_file.relative_path_from(source).to_s
      files << relative unless ignored?(relative, rules)
    end

    files.sort
  end

  def copy_template(source, dest)
    source.glob("**/*", File::FNM_DOTMATCH).each do |src_file|
      next if src_file.directory?
      next if src_file.basename.to_s == "." || src_file.basename.to_s == ".."

      relative = src_file.relative_path_from(source)
      dest_file = dest.join(relative)
      dest_file.dirname.mkpath
      FileUtils.cp(src_file, dest_file)
    end
  end
end

BaseCLI.start(ARGV)
